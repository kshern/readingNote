
# chapter1 文化


## Doug Mcllroy:

1. 让每个程序就做好一件事。如果有新任务，就重新开始，不要往源程序中加入新功能而搞得复杂。
2. 假定每个程序的输入都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式的输入。不要坚持使用交互式输入。
3. 尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。
4. 优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事必先利其器。

总结：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。


## Rob Pike：

1. 你无法断定程序会在什么地方耗费运行时间。瓶颈经常会出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。
2. 估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。
3. 花哨的算法在n很小时通常很慢，而n通常很小。花哨的算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨的算法（即使n很大，也优先考虑原则2）
4. 花哨的算法比简单的算法更容易出bug、更难实现。尽量使用简单的算法配合简单的数据结构。（拿不准就穷举 --Ken Thompson）
5. 数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织的井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法。
6. 没有原则6


## 整体概括：

1. 模块原则：使用简单的接口拼合简单的部件。
编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度--用清晰的接口把若干简单的模块组合成一个复杂软件

2. 清晰原则：清晰胜于机巧。
代码不光是给机器执行的，更是给人看的；不能为了取得程序一丁点的性能提升而大幅增加技术的复杂性和晦涩性，容易滋生bug以及未来维护

3. 组合原则：设计时考虑拼接组合。
采用简单的格式；建议输入简单的文本流处理为简单的文本输出流。
程序彼此独立；无痛替换。
复杂的交互程序和干粗活的算法程序分离。


4. 分离原则：策略同机制分离，接口同引擎分离。
应用按库来编写

5. 简洁原则：设计要简洁，复杂度能低则低。
6. 吝啬原则：除非确无他法，不要编写庞大的程序。
7. 透明性原则：设计要可见，以便审查和调试。
一眼就能看出来怎么回事；程序越透明，也就越健壮

8. 健壮原则：健壮源于透明与简洁。



9. 表示原则：把知识叠入数据以求逻辑质朴而健壮。
主动将代码的复杂度转移到数据之中去

10. 通俗原则：接口设计避免标新立异。
最少惊奇原则
11. 缄默原则：如果一个程序没什么好说的，就沉默。
12. 补救原则：出现异常，马上退出并给出足够的错误信息。
13. 经济原则： 宁花机器一分，不花程序员一秒
14. 生成原则：避免手工hack，尽量编写程序去生成程序
15. 优化原则：雕琢之前先要有原型，跑之前先要学会走路
过早的优化是万恶之源；先制作原型，再精雕细琢。优化之前确保能用。先求运行，再求正确，最后求快

16. 多样原则：决不相信所谓“不二法门”的断言
17. 设计着眼未来，未来总比预想来的快


总结：
K.I.S.S.
Keep It Simple,Stupid!


## 部分实践

1. 只要可行，一切都应该做成与来源和目标无关的过滤器
2. 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）
3. 数据库部署和应用协议应尽可能文本话（让人可读可编辑）
4. 前后端分离
5. 搭建原型
6. 当且仅当只用一门语言编程会提高程序的复杂度时，混用语言编程才比单一语言编程来的好
7. 宽收严发（对接收的东西要包容，对输出的东西要严格）
8. 过滤时，不需要丢弃的信息绝不丢
9. 小而美。在确保完成任务的基础上，程序功能尽可能的少

